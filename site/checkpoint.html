<!DOCTYPE html>
<html>

<head>
  <title>Cachemulator: Checkpoint</title>
  <meta charset="UTF-8">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body><xmp theme="simplex">
# Checkpoint
**Yuyang Guo** (yuyangg) and **Isaac Lim** (idl)

***
## Completed Work

### Pin

As suggested by Yixin, we started using
[Pintool](https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool)
to generate memory traces, given an input *object file*. While we were
originally using Valgrind's lackey tool to do this, it didn't support
multithreaded programs, while Pin does. We wrote a *pintool* that attaches to
`pin` and prints out the memory instruction type, the address being accessed,
and the thread ID performing it. Here is a short sample trace:
```
R 0x7fff9012 0
R 0x7fff9014 1
R 0x7fff9018 2
R 0x7fff9020 0
W 0x7fff9036 0
```
We can then feed the generated `.trace` file into our emulator.

### Emulator

We spent an appreciable amount of time designing the object hierarchy of our
emulator, to avoid design issues later on. Currently, each processor is
assigned a `CMCache` object containing a fixed number of `CMSet` objects, each
containing a fixed number of `CMLine` objects (depending on set associativity).
In addition, we have `CMAddr` objects that encapsulate the `tag` and `block`
properties of an address.

`CMCache` is currently a correct sequential LRU cache (we have not yet
implemented multiple processor support). When fed a stream of addresses
formatted above, it correctly reports HIT, MISS or EVICT, depending on the
access pattern of the previous requests.

### Test harness

We have a functioning test harness that reads in a `.trace` file as formatted
above, and iterates through each memory access, and feeds them into the
`CMCache`, generating the state of that request:
```
$ make
$ ./cache -t traces/easy1.trace
R at 0x7fff9012 on thread 0: MISS
R at 0x7fff9014 on thread 1: HIT
R at 0x7fff9018 on thread 2: HIT
R at 0x7fff9020 on thread 0: MISS
W at 0x7fff9036 on thread 0: MISS
W at 0x7fff9042 on thread 0: MISS
R at 0x7fff9012 on thread 0: HIT
R at 0x7fff9012 on thread 1: HIT
R at 0x7fff9036 on thread 0: HIT
R at 0x4fff9012 on thread 2: MISS
```

***
## State of Goals

We are doing OK with respect to our goals, though a little behind on schedule,
as expected, due to the workload from all our classes. However, we expect to
make good progress over the remaining weeks to stick to all our intended
deliverables. These goals are:

- Implement the bus controller and arbitrator
- Fully implement the **MSI** coherence protocol
- Fully implement **MESI** and **MESIF** protocols
- Extend the test harness to be able to compare the two protocols
- Allow a programmer to submit arbitrary multicore C++ code, extract its memory
  trace, and run it on the emulator.

***
## Parallelism Competition

At this point in time, we plan to demo the *Cachemulator* running on arbitrary
multicore C++ code, and being able to analyze its cache performance. We will
also *fix* the input program trace, and switch between coherence protocols to
show the difference between the two. We will also show graphs that we plotted
beforehand, for a more quantitative analysis.

***
## Schedule

### Original Schedule

| Dates           | Proposed plan                                     |
|-----------------|---------------------------------------------------|
| Mar 31 - Apr 6  | Planning and Design                               |
| Apr 7 - Apr 13  | Basic non-coherent cache, memory and test harness |
| Apr 14 - Apr 20 | Bus, cache and memory controllers (MSI)           |
| Apr 21 - Apr 27 | Extend structure for directory-based              |
| Apr 28 - May 4  | Write API, and use the system to perform analysis |
| May 5 - May 9   | Finalize system, stretch goals                    |

### Revised Schedule

We plan to pair-program all these tasks, since we work better together than
in parallel (hehe).

| Dates           | Proposed plan                                     |
|-----------------|---------------------------------------------------|
| Apr 14 - Apr 17 | Test harness, and correct uniprocessor cache      |
| Apr 18 - Apr 20 | Make uniprocessor cache robust                    |
| Apr 21 - Apr 24 | Bus and memory controllers                        |
| Apr 25 - Apr 27 | Tie in bus controller to MSI protocol             |
| Apr 28 - May 1  | Implement MESI and MESIF                          |
| May 2 - May 4   | Run emulator on memory traces from real programs  |
| May 5 - May 8   | Use the system to perform analysis                |
| May 9           | Parallelism competition                           |

</xmp></body>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>

</html>
