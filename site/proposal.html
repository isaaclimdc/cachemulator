<!DOCTYPE html>
<html>

<head>
  <title>Cachemulator: Project Proposal</title>
  <meta charset="UTF-8">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body><xmp theme="simplex">
**Yuyang Guo** (yuyangg) and **Isaac Lim** (idl)

***
## Summary

Cachemulator is a coherent multi-processor cache emulator that uses a
**snooping**-based cache coherent protocol. We have 2 goals:

- Compare the performance of the MSI / MESI / MESIF protocols
- Provide cache usage information including bus traffic, hits/misses/evictions,
total *ticks* required, highly contended cache lines, false sharing, etc.

***
## Background

In the Introduction to Computer Systems class, we were required to write a
cache simulator in *CacheLab*. This
simulator was very basic, and did not account for multi-core parallelism.
Cachemulator is a multi-processor version of this, with the goal of exhibiting
**simulated** empirical evidence of the performance of various coherence
protocols.

Cache coherence refers to the consistency of data in the same address, across
each processor's local cache. When a single address is shared by processors
and processors *A* and *B* are reading from it, if processor *C* wants to
write a new value into that address, the local copies in *A* and *B*'s caches
need to be updated. There are two main protocols that ensure this
invariant: *snooping* and *directory-based*.

The **snooping** protocol requires any processor that wants to interact with an
address to first broadcast *to all other processors*, the fact that it needs
to gain exclusive access to that address. The **directory-based** protocol
allows only the processors involved in the transaction to talk *directly* to
each other. Each protocol has its pros and cons; this is what we seek to
investigate with Cachemulator.

***
## The Challenge

As we learned in class, there are many parts to a solution that maintains
cache coherence, and this is true for the three protocols (MSI, MESI, and MESIF)
that we intend to
implement. One of the main challenges, is since we are aiming to simulate
the real-life behavior of a *real* cache in a multi-processor system, we have
to make this behavior as accurate as possible. This means everything from the
granularity of requesting access to the bus from the arbitrator, to
keeping every processor's cache in step with the MSI protocol, must work
*perfectly*. In addition, the testing harness we will write must be able to
exploit any inconsistencies with the simulator.

Since we are writing executable C++ code, clearly our simulator will also be
succeptible to the nuances of performance on the *actual cache*. We need to
make sure that the way we simulate behavior will not be affected by these
factors.

***
## Resources

We will use our code from 15-213's *CacheLab* as reference for an implementation
of a cache simulator. However we won't just be building off of this, since
our implementation would need to be drastically different in order to implement
cache coherence.

Theoretically, our Cachemulator does not have any requirements for computation
resources, because the performance of the simulator itself, though important,
is not the biggest concern. We will be keeping an internal timer counter that
is *architecture-independent* to evaluate cache usage.

For specificity though, we will likely run our code on the Gates 3000
machines, or even locally.

***
## Goals / Deliverables

### Immediate plans
- A performance evaluation of different cache coherence protocols under
different types of workloads.

- A C++ API that programmers can use, instead of the runtime library memory
functions (e.g. `malloc`, memory accesses, etc.) to evaluate cache usage.

### Stretch goals
- To develop a runtime cache simulator that takes executables and analyzes
their cache usage based on their memory access trace. This means being able
to tell a developer what the cache usage pattern of their program is, and
identify any problems, such as instances of false sharing, etc.

***
## Platform Choice

As described in the "Resources" session, our project will culminate in a
tool for analyzing parallel programs, but won't be a parallel program itself.
And so we have no specific platform choice; in fact, we would *prefer* for
our project to be platform-independent, allowing it to be as flexible as
possible.

***
## Proposed Schedule

| Dates           | Proposed plan                                     |
|-----------------|---------------------------------------------------|
| Mar 31 - Apr 6  | Planning and Design                               |
| Apr 7 - Apr 13  | Basic non-coherent cache, memory and test harness |
| Apr 14 - Apr 20 | Bus, cache and memory controllers (MSI)           |
| Apr 21 - Apr 27 | Extend structure for directory-based              |
| Apr 28 - May 4  | Write API, and use the system to perform analysis |
| May 5 - May 9   | Finalize system, stretch goals                    |

</xmp></body>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>

</html>
